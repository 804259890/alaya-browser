
## 链上接口调用汇总
功能点|链上接口调用|处理逻辑
---|---|---
获取区块及交易|Web3j.ethGetBlockByNumber()<br>CandidateContract.GetCandidateDetails()<br>Web3j.ethGetCode()|区块处理：<br>1、根据区块extraData计算出出块节点公钥;<br/>2、调用候选节点合约获取节点分红比例<br/>3、分析区块内的交易类型取得投票数和质押交易数<br/>交易处理：<br/>1、根据交易中的Code设置交易接收者的类型(普通地址、合约地址)
获取节点信息|CandidateContract.GetCandidateList()<br/>CandidateContract.GetVerifiersList()<br/>TicketContract.GetCandidateTicketCount()|
待处理交易信息|Web3j.ethPendingTx()<br/>Web3j.ethGetCode()|1、根据交易中的Code设置交易接收者的类型(普通地址、合约地址)
查节点有效票|TicketContract.GetCandidateTicketCount()|1、根据节点ID列表获取有效票数
查节点票价|TicketContract.GetTicketPrice()|1、获取当前票价
查余额|Web3j.ethGetBalance()|1、查询账户余额
获取链上投票数|TicketContract.GetPoolRemainder()|1、投票数通过：51200减去GetPoolRemainder()取得的数量获得


## 指标信息运算逻辑
指标信息|处理逻辑
---|---
地址投票节点数|根据地址查询所有投票交易信息，从投票参数中获取所有节点ID，统计出此地址的投票节点数
节点中选次数|(节点的结束区块-节点的起始区块)/250 向下取整
区块奖励|f(x) = 10亿 * 1.025 ^( x / 24 * 3600 * 365) , g(x) = f(x) -f(x-1)/24 * 3600 * 365 , x(块高)/24 * 3600 * 365 =  轮数，g(x)为当前块的奖励
累计共识奖励|累加（区块奖励 * 分红比例 + 当前区块的手续费总和）
累计投票奖励|累加（区块奖励 * (1-分红比例)）
平均出块时长|统计最近3600个区块的平均出块时长
交易TPS|取1s内出的所有区块，统计这些块内的交易数量作为TPS

## 期望提供变更的流程

期望底层提供的信息：

* A.变更
    由底层主动提供，写日志或者消息队列，具体实现方式有待商榷
    以区块为单元，每个单元中包含以下的原子
    
        1.交易
        
        2.投票合约
        
        3.质押合约
        
    由于底层现阶段是之提供实时是状态，但是由于每次实时状态的变更都是以区块为单位去更新已有的提供的数据，所以只查询的到最新的信息
    但是如果每次以区块打包的交易去更新PPOS合约信息以及相关信息时，在吐给浏览器，相当于有个历史的变更信息，也就是流水存量信息
           
* B.查询

    a.区块
    
        区块结构中新增：
        
            1.区块奖励
            2.当前块时候的票价
    b.节点
        
        节点列表中新增：
            
            1.节点类型
            2.累计奖励
            3.选中次数
            4.出块数
